import 'package:hive_flutter/hive_flutter.dart';
import 'package:scorecard/models/ball.dart';
import 'package:scorecard/models/cricket_match.dart';
import 'package:scorecard/models/innings.dart';
import 'package:scorecard/models/player.dart';
import 'package:scorecard/models/team.dart';
import 'package:scorecard/models/wicket.dart';
import 'package:scorecard/repositories/generic_repository.dart';
import 'package:scorecard/repositories/hive_constants.dart';
import 'package:scorecard/util/utils.dart';

class CricketMatchRepository implements IRepository<CricketMatch> {
  late final Box<CricketMatchDTO> _cricketMatchBox; // lmao MatchBox

  final IRepository<Player> _playerRepository;
  final IRepository<Team> _teamRepository;

  CricketMatchRepository({
    required IRepository<Player> playerRepository,
    required IRepository<Team> teamRepository,
  })  : _playerRepository = playerRepository,
        _teamRepository = teamRepository;

  @override
  Future<void> initialize() async {
    // Register the TypeAdapter
    Hive.registerAdapter(_CricketMatchAdapter());

    // Open the Hive Box
    _cricketMatchBox = await Hive.openBox(cricketMatchBoxName);
  }

  @override
  Future<void> add(CricketMatch cricketMatch) async {
    // Ensure that both teams are in the Database
    for (final team in [cricketMatch.home.team, cricketMatch.away.team]) {
      _teamRepository.add(team);
    }

    final cricketMatchDTO = CricketMatchDTO.of(cricketMatch);
    _cricketMatchBox.put(cricketMatch.id, cricketMatchDTO);
  }

  @override
  Future<CricketMatch> get(String id) async {
    final cricketMatchDTO = _cricketMatchBox.get(id);
    if (cricketMatchDTO == null) {
      throw StateError("CricketMatch not found in the Database! (id: $id)");
    }
    final cricketMatch = await cricketMatchDTO.toCricketMatch(
        teamRepository: _teamRepository, playerRepository: _playerRepository);
    return cricketMatch;
  }

  @override
  Future<List<CricketMatch>> getAll() async {
    final cricketMatchDTOs = _cricketMatchBox.values;
    final cricketMatches = [
      for (final cricketMatchDTO in cricketMatchDTOs)
        await cricketMatchDTO.toCricketMatch(
          teamRepository: _teamRepository,
          playerRepository: _playerRepository,
        )
    ];
    return cricketMatches;
  }

  @override
  Future<void> update(CricketMatch cricketMatch) async {
    // Ensure that a cricket match of the same ID exists in the database.
    // This is just to ensure that update() is called intentionally.
    // If a new player is to be added, add() should be called instead.
    if (!_cricketMatchBox.containsKey(cricketMatch.id)) {
      throw StateError(
          "CricketMatch not found in the Database! (id: ${cricketMatch.id})");
    }

    // Since the ID is not generated by the database, adding is essentially the
    // same as updating.
    await add(cricketMatch);
  }

  @override
  Future<void> delete(String id) async {
    await _cricketMatchBox.delete(id);
  }
}

class CricketMatchDTO {
  final String id;
  final TeamSquadDTO home;
  final TeamSquadDTO away;
  final int maxOvers;
  final List<InningsDTO> inningsList;
  final TossDTO? toss;
  final bool isCompleted;
  final bool isHomeInningsFirst;
  final DateTime createdAt;

  CricketMatchDTO._({
    required this.id,
    required this.home,
    required this.away,
    required this.maxOvers,
    required this.inningsList,
    required this.toss,
    required this.isCompleted,
    required this.isHomeInningsFirst,
    required this.createdAt,
  });

  Future<CricketMatch> toCricketMatch({
    required IRepository<Team> teamRepository,
    required IRepository<Player> playerRepository,
  }) async =>
      CricketMatch.load(
        id: id,
        home: await home.toTeamSquad(
          teamRepository: teamRepository,
          playerRepository: playerRepository,
        ),
        away: await away.toTeamSquad(
          teamRepository: teamRepository,
          playerRepository: playerRepository,
        ),
        maxOvers: maxOvers,
        inningsList: [
          // TODO Make this lazy
          for (final inningsDTO in inningsList)
            await inningsDTO.toInnings(
              teamRepository: teamRepository,
              playerRepository: playerRepository,
            )
        ],
        toss: toss == null
            ? null
            : await toss!.toToss(teamRepository: teamRepository),
        isCompleted: isCompleted,
        isHomeInningsFirst: isHomeInningsFirst,
        createdAt: createdAt,
      );

  factory CricketMatchDTO.of(CricketMatch match) => CricketMatchDTO._(
        id: match.id,
        home: TeamSquadDTO.of(match.home),
        away: TeamSquadDTO.of(match.away),
        maxOvers: match.maxOvers,
        inningsList: [
          for (final innings in match.inningsList) InningsDTO.of(innings)
        ],
        toss: match.toss == null ? null : TossDTO.of(match.toss!),
        isCompleted: match.isCompleted,
        isHomeInningsFirst: match.isHomeInningsFirst,
        createdAt: match.createdAt,
      );

  Map<String, dynamic> toMap() => {
        "id": id,
        "home": home.toMap(),
        "away": away.toMap(),
        "maxOvers": maxOvers,
        "inningsList": [for (final innings in inningsList) innings.toMap()],
        "toss": toss?.toMap(),
        "isCompleted": isCompleted,
        "isHomeInningsFirst": isHomeInningsFirst,
        "createdAt": createdAt,
      };

  factory CricketMatchDTO.fromMap(Map<String, dynamic> map) =>
      CricketMatchDTO._(
        id: map["id"],
        home: TeamSquadDTO.fromMap(map["home"]),
        away: TeamSquadDTO.fromMap(map["away"]),
        maxOvers: map["maxOvers"],
        inningsList: [
          for (final innings in map["inningsList"]) InningsDTO.fromMap(innings)
        ],
        toss: map["toss"] == null ? null : TossDTO.fromMap(map["toss"]),
        isCompleted: map["isCompleted"],
        isHomeInningsFirst: map["isHomeInningsFirst"],
        createdAt: map["createdAt"],
      );
}

class TeamSquadDTO {
  final String team;
  final List<String> squad;

  TeamSquadDTO._({required this.team, required this.squad});

  Future<TeamSquad> toTeamSquad({
    required IRepository<Team> teamRepository,
    required IRepository<Player> playerRepository,
  }) async =>
      TeamSquad(
        team: await teamRepository.get(team),
        squad: <Player>[
          for (final playerId in squad) await playerRepository.get(playerId)
        ],
      );

  factory TeamSquadDTO.of(TeamSquad teamSquad) => TeamSquadDTO._(
        team: teamSquad.team.id,
        squad: teamSquad.squad.map((player) => player.id).toList(),
      );

  Map<String, dynamic> toMap() => {
        "team": team,
        "squad": squad,
      };

  factory TeamSquadDTO.fromMap(Map<String, dynamic> map) => TeamSquadDTO._(
        team: map["team"],
        squad: map["squad"],
      );
}

class TossDTO {
  final String winningTeam;
  final int tossChoice;

  TossDTO._({required this.winningTeam, required this.tossChoice});

  Future<Toss> toToss({
    required IRepository<Team> teamRepository,
  }) async =>
      Toss(
        await teamRepository.get(winningTeam),
        TossChoice.values[tossChoice],
      );

  factory TossDTO.of(Toss toss) => TossDTO._(
        winningTeam: toss.winningTeam.id,
        tossChoice: toss.choice.index,
      );

  Map<String, dynamic> toMap() => {
        "winningTeam": winningTeam,
        "tossChoice": tossChoice,
      };

  factory TossDTO.fromMap(Map<String, dynamic> map) => TossDTO._(
        winningTeam: map["winningTeam"],
        tossChoice: map["tossChoice"],
      );
}

class InningsDTO {
  final TeamSquadDTO battingTeam;
  final TeamSquadDTO bowlingTeam;
  final int? target;
  final int maxOvers;
  final List<BallDTO> balls;
  final List<String> batters;
  final List<String> bowlers;
  final String batter1;
  final String? batter2;
  final String striker;
  final String bowler;

  InningsDTO._({
    required this.battingTeam,
    required this.bowlingTeam,
    required this.target,
    required this.maxOvers,
    required this.balls,
    required this.batters,
    required this.bowlers,
    required this.batter1,
    required this.batter2,
    required this.striker,
    required this.bowler,
  });

  Future<Innings> toInnings({
    required IRepository<Team> teamRepository,
    required IRepository<Player> playerRepository,
  }) async =>
      Innings.load(
        battingTeam: await battingTeam.toTeamSquad(
            teamRepository: teamRepository, playerRepository: playerRepository),
        bowlingTeam: await bowlingTeam.toTeamSquad(
            teamRepository: teamRepository, playerRepository: playerRepository),
        maxOvers: maxOvers,
        target: target,
        balls: [
          for (final ballDTO in balls)
            await ballDTO.toBall(playerRepository: playerRepository)
        ],
        batters: [
          for (final batter in batters) await playerRepository.get(batter)
        ],
        bowlers: [
          for (final bowler in bowlers) await playerRepository.get(bowler)
        ],
        batter1: await playerRepository.get(batter1),
        batter2: batter2 == null ? null : await playerRepository.get(batter2!),
        striker: await playerRepository.get(striker),
        bowler: await playerRepository.get(bowler),
      );

  factory InningsDTO.of(Innings innings) => InningsDTO._(
        battingTeam: TeamSquadDTO.of(innings.battingTeam),
        bowlingTeam: TeamSquadDTO.of(innings.bowlingTeam),
        target: innings.target,
        maxOvers: innings.maxOvers,
        balls: [for (final ball in innings.balls) BallDTO.of(ball)],
        batters: [
          for (final batterInn in innings.batterInningsList) batterInn.batter.id
        ],
        bowlers: [
          for (final bowlerInn in innings.bowlerInningsList) bowlerInn.bowler.id
        ],
        batter1: innings.playersInAction.batter1.batter.id,
        batter2: innings.playersInAction.batter2?.batter.id,
        striker: innings.playersInAction.striker.batter.id,
        bowler: innings.playersInAction.bowler.bowler.id,
      );

  Map<String, dynamic> toMap() => {
        "battingTeam": battingTeam.toMap(),
        "bowlingTeam": bowlingTeam.toMap(),
        "target": target,
        "maxOvers": maxOvers,
        "balls": [for (final ball in balls) ball.toMap()],
        "batters": batters,
        "bowlers": bowlers,
        "batter1": batter1,
        "batter2": batter2,
        "striker": striker,
        "bowler": bowler,
      };

  factory InningsDTO.fromMap(Map<String, dynamic> map) => InningsDTO._(
        battingTeam: TeamSquadDTO.fromMap(map["battingTeam"]),
        bowlingTeam: TeamSquadDTO.fromMap(map["bowlingTeam"]),
        target: map["target"],
        maxOvers: map["maxOvers"],
        balls: [for (final ball in map["balls"]) BallDTO.fromMap(ball)],
        batters: map["batters"],
        bowlers: map["bowlers"],
        batter1: map["batter1"],
        batter2: map["batter2"],
        striker: map["striker"],
        bowler: map["bowler"],
      );
}

class BallDTO {
  final String bowler;
  final String batter;
  final int runsScored;
  final int? bowlingExtra;
  final int? battingExtra;
  final WicketDTO? wicket;
  final bool isEventOnly;
  final int overIndex;
  final int ballIndex;
  final DateTime timestamp;

  BallDTO._({
    required this.bowler,
    required this.batter,
    required this.runsScored,
    required this.bowlingExtra,
    required this.battingExtra,
    required this.wicket,
    required this.isEventOnly,
    required this.overIndex,
    required this.ballIndex,
    required this.timestamp,
  });

  Future<Ball> toBall({required IRepository<Player> playerRepository}) async =>
      Ball(
        bowler: await playerRepository.get(bowler),
        batter: await playerRepository.get(batter),
        runsScored: runsScored,
        wicket: wicket == null
            ? null
            : await wicket!.toWicket(playerRepository: playerRepository),
        battingExtra:
            battingExtra == null ? null : BattingExtra.values[battingExtra!],
        bowlingExtra:
            bowlingExtra == null ? null : BowlingExtra.values[bowlingExtra!],
        overIndex: overIndex,
        ballIndex: ballIndex,
        isEventOnly: isEventOnly,
        timestamp: timestamp,
      );

  factory BallDTO.of(Ball ball) => BallDTO._(
        bowler: ball.bowler.id,
        batter: ball.batter.id,
        runsScored: ball.runsScored,
        bowlingExtra: ball.bowlingExtra?.index,
        battingExtra: ball.battingExtra?.index,
        wicket: ball.wicket == null ? null : WicketDTO.of(ball.wicket!),
        isEventOnly: ball.isEventOnly,
        overIndex: ball.overIndex,
        ballIndex: ball.ballIndex,
        timestamp: ball.timestamp,
      );

  Map<String, dynamic> toMap() => {
        "bowler": bowler,
        "batter": batter,
        "runsScored": runsScored,
        "bowlingExtra": bowlingExtra,
        "battingExtra": battingExtra,
        "wicket": wicket?.toMap(),
        "isEventOnly": isEventOnly,
        "overIndex": overIndex,
        "ballIndex": ballIndex,
        "timestamp": timestamp,
      };

  factory BallDTO.fromMap(Map<String, dynamic> map) => BallDTO._(
        bowler: map["bowler"],
        batter: map["batter"],
        runsScored: map["runsScored"],
        bowlingExtra: map["bowlingExtra"],
        battingExtra: map["battingExtra"],
        wicket: map["wicket"] == null ? null : WicketDTO.fromMap(map["wicket"]),
        isEventOnly: map["isEventOnly"],
        overIndex: map["overIndex"],
        ballIndex: map["ballIndex"],
        timestamp: map["timestamp"],
      );
}

class WicketDTO {
  final String batter;
  final String? bowler;
  final String? fielder;
  final int dismissal;

  WicketDTO._({
    required this.batter,
    required this.bowler,
    required this.fielder,
    required this.dismissal,
  });

  Future<Wicket> toWicket(
          {required IRepository<Player> playerRepository}) async =>
      Wicket(
        batter: await playerRepository.get(batter),
        bowler: bowler == null ? null : await playerRepository.get(bowler!),
        fielder: fielder == null ? null : await playerRepository.get(fielder!),
        dismissal: Dismissal.values[dismissal],
      );

  factory WicketDTO.of(Wicket wicket) => WicketDTO._(
        batter: wicket.batter.id,
        bowler: wicket.bowler?.id,
        fielder: wicket.fielder?.id,
        dismissal: wicket.dismissal.index,
        // TODO Maybe change all enum DTOs to value(String) instead of index(int)
      );

  Map<String, dynamic> toMap() => {
        "batter": batter,
        "bowler": bowler,
        "fielder": fielder,
        "dismissal": dismissal,
      };

  factory WicketDTO.fromMap(Map<String, dynamic> map) => WicketDTO._(
        batter: map["batter"],
        bowler: map["bowler"],
        fielder: map["fielder"],
        dismissal: map["dismissal"],
      );
}

class _CricketMatchAdapter extends TypeAdapter<CricketMatchDTO> {
  @override
  int get typeId => cricketMatchTypeId;

  @override
  CricketMatchDTO read(BinaryReader reader) =>
      CricketMatchDTO.fromMap(Utils.castMap(reader.readMap()));

  @override
  void write(BinaryWriter writer, CricketMatchDTO obj) {
    writer.writeMap(obj.toMap());
  }
}
