import 'package:hive_flutter/adapters.dart';
import 'package:scorecard/models/player.dart';
import 'package:scorecard/repositories/generic_repository.dart';
import 'package:scorecard/repositories/hive_constants.dart';

class PlayerRepository implements IRepository<Player> {
  late final Box<PlayerDTO> _playerBox;

  /// A cache is needed to ensure that only one object of a Player exists
  /// throughout the app.
  final Map<String, Player> _cache = {};

  @override
  Future<void> initialize() async {
    // Register the TypeAdapter
    Hive.registerAdapter(_PlayerAdapter());

    // Open the Hive Box
    _playerBox = await Hive.openBox(playerBoxName);
  }

  @override
  Future<void> add(Player player) async {
    final playerDTO = PlayerDTO.of(player);
    await _playerBox.put(playerDTO.id, playerDTO);
    _cache[player.id] = player;
  }

  @override
  Future<Player> get(String id) async {
    final cachedPlayer = _cache[id];

    if (cachedPlayer != null) {
      return cachedPlayer;
    }

    final playerDTO = _playerBox.get(id);
    if (playerDTO == null) {
      throw StateError("Player not found in the Database! (id: $id)");
    }
    final player = playerDTO.toPlayer();

    _cache[id] = player;

    return player;
  }

  @override
  Future<List<Player>> getAll() async {
    final playerDTOs = _playerBox.values;
    final players = [for (final playerDTO in playerDTOs) playerDTO.toPlayer()];
    return players;
  }

  @override
  Future<void> update(Player player) async {
    // Ensure that a player of the same ID exists in the database.
    // This is just to ensure that update() is called intentionally.
    // If a new player is to be added, add() should be called instead.
    if (!_playerBox.containsKey(player.id)) {
      throw StateError("Player not found in the Database! (id: ${player.id})");
    }
    // Since the ID is not generated by the database, adding is essentially the
    // same as updating.
    await add(player);
  }

  @override
  Future<void> delete(String id) async {
    await _playerBox.delete(id);
    _cache.remove(id);
  }
}

/// Represents a [Player] as it is stored in the database.
class PlayerDTO {
  final String id;
  final String name;
  final int batArm;
  final int bowlArm;
  final int bowlStyle;

  PlayerDTO._({
    required this.id,
    required this.name,
    required this.batArm,
    required this.bowlArm,
    required this.bowlStyle,
  });

  Player toPlayer() => Player(
        id: id,
        name: name,
        batArm: Arm.values[batArm],
        bowlArm: Arm.values[bowlArm],
        bowlStyle: BowlStyle.values[bowlStyle],
      );

  factory PlayerDTO.of(Player player) => PlayerDTO._(
        id: player.id,
        name: player.name,
        batArm: player.batArm.index,
        bowlArm: player.bowlArm.index,
        bowlStyle: player.bowlStyle.index,
      );

  Map<String, dynamic> toMap() => {
        "id": id,
        "name": name,
        "batArm": batArm,
        "bowlArm": bowlArm,
        "bowlStyle": bowlStyle,
      };

  factory PlayerDTO.fromMap(Map<String, dynamic> map) => PlayerDTO._(
        id: map["id"],
        name: map["name"],
        batArm: map["batArm"],
        bowlArm: map["bowlArm"],
        bowlStyle: map["bowlStyle"],
      );
}

class _PlayerAdapter extends TypeAdapter<PlayerDTO> {
  @override
  int get typeId => playerTypeId;

  @override
  PlayerDTO read(BinaryReader reader) =>
      PlayerDTO.fromMap(reader.readMap().cast());

  @override
  void write(BinaryWriter writer, PlayerDTO obj) {
    writer.writeMap(obj.toMap());
  }
}
